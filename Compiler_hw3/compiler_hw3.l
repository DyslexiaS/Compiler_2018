/* Definition section */
%{
#include <stdio.h>
#include <stdlib.h>
#include "common.h"
#include "y.tab.h"	/* header file generated by bison */
extern YYSTYPE yylval; //YYSTYPE
int fnum;
char FUNC_NAME[100][20];
bool is_func(char* fname);
void add_fname(const char* fname);

 #define DEBUG 

#ifdef DEBUG

#define my_return(OP) 	printf(" %s\t%s\n", yytext, #OP);	\
				return(OP)				
#else

#define my_return(OP)		return(OP)				

#endif


%}

/* Define regular expression label */
newline		[\n]
digit		[0-9]
letter		[a-zA-Z]
integer         {digit}+
double          {digit}+"."{digit}+
id		{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE FUNCTION_STATE

/* Rules section */
%%

 /* Arithmetic */
"+"     { my_return(ADD); }
"-" 	{ my_return(SUB); }
"*" 	{ my_return(MUL); }
"/" 	{ my_return(DIV); }
"%"     { my_return(MOD); }
"++"    { my_return(INC); }
"--"    { my_return(DEC); }

 /* Relational */
">"	{ my_return(GT); }
"<"	{ my_return(LT); }
">="	{ my_return(GE); }
"<="	{ my_return(LE); }
"=="	{ my_return(EQ); }
"!="	{ my_return(NE); }

 /* Assignment */
"="	{  my_return(ASSIGN); }
"+="	{ my_return(ADD_ASSIGN); }
"-="	{ my_return(SUB_ASSIGN); }
"*="	{ my_return(MUL_ASSIGN); }
"/="	{ my_return(DIV_ASSIGN); }
"%="	{ my_return(MOD_ASSIGN); }

 /* Logical */
"&&"	{ my_return(AND); }
"||"	{ my_return(OR); }
"!"	{ my_return(NOT); }

 /* Delimiters */
"("		{ my_return(LB); }
")"		{ my_return(RB); }
"{"		{ my_return(LCB); }
"}"		{ my_return(RCB); }

 /* Print Keywords */	
"print"		{ my_return(PRINT); }
"println"	{ my_return(PRINTLN); }

 /* Condition and Loop Keywords */
"if"		{ my_return(IF); }
"else"		{ my_return(ELSE); }
"for"		{ my_return(FOR); }
";"         { return ';'; }
","         { return ','; }

 /* Declaration Keywords */
"var"		{ my_return(VAR); }
"void"		{ my_return(VOID); }
"int"		{ my_return(INT); }
"float32"	{ my_return(FLOAT); }
"return"	{ my_return(RET); }

 /* Function declaration */
"func"                  { BEGIN FUNCTION_STATE; my_return(FUNC); }
<FUNCTION_STATE>{id}    {   BEGIN INITIAL;
                            yylval.string = strdup(yytext);
                            add_fname(yylval.string);
                            my_return(F_NAME); }

 /* String Constant */
\"				{ BEGIN STRING_STATE;}
<STRING_STATE>\"		{ BEGIN INITIAL;}
<STRING_STATE>[^"]*		{ yylval.string = strdup(yytext); my_return(STRING);}

 /* Number Constant */
{integer}	{ yylval.i_val = atoi(yytext);  my_return(I_CONST); }
{double}	{ yylval.f_val = atof(yytext);  my_return(F_CONST); }

 /* C type Comment */
"/*"			{ BEGIN COMMENT; }
<COMMENT>[^*\n]+	{ }
<COMMENT>\n		{ }
<COMMENT>"*"		{ }
<COMMENT>"*/"		{ BEGIN INITIAL; }

 /* C++ type Comment */
\/\/.*	{ }

 /* Variable ID */
 {id}           {   yylval.string = strdup(yytext); 
                    if(is_func(yylval.string)){
                        my_return(F_NAME);
                    }else{
                        my_return(ID);
                    }
                }

 /* others */
[\n]		{ my_return(NEWLINE); }
[ \t]		{ } /* Ignore */
[^; \t] 	{ } /* Ignore other charactor sets */
<<EOF>>         { return 0; }

%%

int yywrap()
{
    return 1;
}
void add_fname(const char* fname){
    strcpy(FUNC_NAME[fnum++], fname);
}
int fnum;
char FUNC_NAME[100][20];
bool is_func(char* fname){
    for(int i=0 ; i<fnum ; ++i)
        if(!strcmp(FUNC_NAME[i], fname))
            return true;
    return false;
}
